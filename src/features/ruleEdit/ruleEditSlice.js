import { 
  createSlice, 
  createAsyncThunk, 
  current } from '@reduxjs/toolkit'
import * as R from 'ramda'

// import { 
//   transactionsFetch
// }
// from 'features/transactions/transactionsSlice'
// import { rulesFetch } from 'features/rules/rulesSlice'
import * as Promise from 'bluebird'
import api from 'api'
import shortid from 'shortid'
import criteria from 'fields/criteria'
import { 
  transactionFields as tFields
} from 'fields/transactionFields'
import { 
  actionTypes, 
} from 'fields/actionFields'


// eslint-disable-next-line
import { blue } from 'logger'

const getActiveCriteria = (criteria) => {
  return criteria === null ? [] : criteria.filter((c) => c.active === true)
}

const removeInactiveCriteria = (rule) => {
  const { criteria } = rule
  const activeCriteria = getActiveCriteria(criteria)
  return R.mergeRight(rule, { criteria: activeCriteria })
}

const removeTmpIdField = (rule) => {
  return R.has('_id')
    ? R.dissoc('_id', rule)
    : rule
}

export const ruleCreate = createAsyncThunk(
  'rules/rule-create',
  async (rule) => {
    const newRule = R.pipe(
      removeInactiveCriteria,
      removeTmpIdField
    )(rule)
    await api.rules.create(newRule)
    Promise.all([
      api.views.read('all-data-by-description'),
      api.rules.read()
    ])
  }
)

export const ruleUpdate = createAsyncThunk(
  'rules/rule-update',
  async (rule) => {
    const newRule = removeInactiveCriteria(rule)
    await api.rules.update(rule._id, newRule)
    Promise.all([
      api.views.read('all-data-by-description'),
      api.rules.read()
    ])
  }
)

const initialState = {}

const ruleEditSlice = createSlice({
  name: 'ruleEdit',
  initialState,
  reducers: {
    ruleEditSet(state, action) {
      const { payload } = action
      state.ruleEdit = payload // || {}
    },
    ruleEditClear(state, action) {
      state.ruleEdit = {}
    },
    ruleEditCriterionUpdate(state, action) {
      const newCriterion = action.payload
      const criteria = R.path(['ruleEdit', 'criteria'], state)
      const idx = R.findIndex(R.propEq('_id', R.prop('_id', newCriterion)))(
        criteria
      )
      const newCriteria = R.update(idx, newCriterion, criteria)
      const newState = R.assocPath(['ruleEdit', 'criteria'], newCriteria, state)
      return newState
    },
    ruleEditActionUpdate(state, action) {
      const newAction = action.payload
      const actions = R.path(['ruleEdit', 'actions'], state)
      const idx = R.findIndex(R.propEq('_id', R.prop('_id', newAction)))(
        actions
      )
      const newActions = R.update(idx, newAction, actions)
      const newState = R.assocPath(['ruleEdit', 'actions'], newActions, state)
      return newState
    },
    ruleEditSave(state, action) {
      // if tmpRuleId -> remove the _id field and call insert
      // else call update
    }
  }
})

export default ruleEditSlice.reducer

export const {
  ruleEditClear,
  ruleEditSet,
  ruleEditCriterionUpdate,
  ruleEditActionUpdate
} = ruleEditSlice.actions

// const hasRuleEdit = state => !(R.path(['state', 'ruleEdit']) === null)

/**
 * 
 * @param {*} state 
 * @return {object} state.ruleEdit
 */
export const selectRuleEdit = (state) => {
  const ruleEdit = R.path(['ruleEdit', 'ruleEdit',], state)
  return R.isNil(ruleEdit) ? {} : ruleEdit
}

/**
 * 
 * @param {object} state 
 * @returns {array} Returns criteria from state.ruleEdit
 */
export const selectRuleEditCriteria = (state) => {
  const criteria = R.path(['ruleEdit', 'ruleEdit', 'criteria'], state)
  return R.isNil(criteria) ? [] : criteria
}

/**
 * 
 * @param {object} state 
 * @returns {array} 
 * @description Gets criteria from state.RuleEdit where criteria.active===true
 */
export const selectActiveCriteria = (state) => {
  const criteria = R.path(['ruleEdit', 'ruleEdit', 'criteria'], state)
  return R.isNil(criteria) ? [] : getActiveCriteria(criteria)
}

/**
 * 
 * @param {object} state 
 * @returns {array} 
 * @description Gets criteria from state.RuleEdit where criteria.active===true
 */
export const selectRuleEditActions = (state) => {
  const actions = R.path(['ruleEdit', 'ruleEdit', 'actions'], state)
  return R.isNil(actions) ? [] : actions
}

/**
 * 
 * @param {object} state
 * @returns {string} state.ruleEdit._id
 */
export const selectRuleEditId = (state) => {
  const id = R.path(['ruleEdit', 'ruleEdit', '_id'], state)
  return R.isNil(id) ? '' : id
}


/**
 * @returns {string} A temporary id in the from of 'tmp_' + random
 */
export const ruleTmpMakeId = () => `tmp_${shortid.generate()}`

/**
 * 
 * @param {string} tmpId An id generated by ruleTmpMakeId
 * @param {string} origDescription origDescription from active transaction
 * @param {date} date date from active transaction
 * @returns {object} A new Rule
 */
export const ruleTmpMake = (tmpId, origDescription, date) => {
  const { operators: oFields } = criteria

  return {
    _id: tmpId,
    criteria: [
      {
        _id: `tmp_${shortid.generate()}`,
        field: tFields.description.name,
        operation: oFields.equals.name,
        value: origDescription,
        active: true,
      },
      {
        _id: `tmp_${shortid.generate()}`,
        field: tFields.date.name,
        operation: oFields.equals.name,
        value: date,
        active: false
      }
    ],
    actions: [
      {
        _id: `tmp_${shortid.generate()}`,
        actionType: actionTypes.replaceAll.name,
        field: tFields.description.name,
        replaceWithValue: origDescription
      },
      {
        _id: `tmp_${shortid.generate()}`,
        actionType: actionTypes.categorize.name,
        category1: '',
        category2: '',
      }
    ]
  }
}